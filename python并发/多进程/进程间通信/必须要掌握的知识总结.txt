Process 类
创建进程的
	直接实例化Process target参数
        子类化Process 重写run方法

怎么启动一个新的进程
start()  # 先把这进城启动，然后再去调用这个run
run() 不能启动进程，普通的方法调用


一定记得要把start()的调用写在 __name__ == __main__ 是不是？
在windows上，我们start()一个进程的时候
1. Windows系统会从新打开一个新的Python
2. 接着，Python会自己import 父进程的这个文件
3. 如果不放在__main__下面，那么会无限的创建进程（当然，Python不会让它这么做，所以报错了）


不同的进程，他们之间的所有的变量，都是不共用的。

如果是一个进程，我想要，让一个函数里的修改，在另一个函数里能看见
使用全局变量
但是，在多进程里，他们互相看不见。


如果要让进程间可以通信，就需要： Queue， Manager

队列是先进先出，就是排队
队列，由两头，一头入(put)，一头出(get)
put方法，往队列里加一个人
get方法，把现在队列里，最老的一个人，拿出来


如果我把队列想成，一条隧道，链接山的两边

Manager新开辟了一个空间，是可以通过Manager产生的对象所访问的
mgr = mutiprocessing.Manager() # 生成了一个Manager
d = mgr.dict()  # 在mgr这个空间里，生成了一个字典
d是一个用来访问mgr里面字典的一个对象，索要把这个d传给每一个子进程



put 当队列满了的时候，阻塞（等待）到队列不满
get 当队列为控的时候，阻塞（等待）到队列不为空


生产者消费者的设计思路：
不是：去设计，一个生产者生产了以后，消费者怎么消费
应该：先单独设计两方，然后，只考虑
      消费者只关心队列空还是不空
      生产者只关心队列满还是不满









